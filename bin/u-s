#!/usr/bin/env bash

# Initial CLI helper for any kind of U-S checkout or install

set -e # Sh, same as?:
set -o errexit # Ash, Bash
set -o nounset # Ash, Bash
set -o pipefail # Bash-only


init() #
{
  test -n "$U_S" || return 100

  # Bootstrap SCRIPTPATH and default-libs, then return to main routine
  . $U_S/tools/sh/init.sh && lib_init && U_S_VERSION="$(u_s_version)"
}

edit_docs() # [Files...]
{
  test $# -gt 0 || set -- $U_S/src/man/*/*.md
  $EDITOR "$@"
}

# Edit main command scripts or anything
edit() # [Files...]
{
  test $# -gt 0 || set -- "$@" $U_S/commands/u_s-*.lib.sh
  $EDITOR "$@"
}

# Grep all libs on SCRIPTPATH for expression
libs_grep() # Grep
{
  test $# -eq 1 || return
  local grep="$(libs_paths)"
  grep "$@" $grep
}

# List full path names for sh-lib files on SCRIPTPATH
libs_paths() # [Glob]
{
  test $# -eq 1 || set -- '*'
  echo "$SCRIPTPATH" | tr ':' '\n' | while read scriptpath
  do
    test -e "$scriptpath/$1.lib.sh" -o \
      "$scriptpath/*.lib.sh" != "$(echo $scriptpath/*.lib.sh|head -1)" ||
        continue
    echo $scriptpath/$1.lib.sh; done
}

# List only the names of sh-libs on SCRIPTPATH
libs_list() # [Glob]
{
  test $# -lt 2 || return
  test $# -eq 1 || set -- '*'
  echo "$SCRIPTPATH" | tr ':' '\n' | while read scriptpath
  do
    test -e "$scriptpath/$1.lib.sh" -o \
      "$scriptpath/*.lib.sh" != "$(echo $scriptpath/*.lib.sh|head -1)" ||
        continue

    # NOTE: no spaces on SCRIPTPATH
    len="${#scriptpath}"
    echo $scriptpath/$1.lib.sh | tr ' ' '\n' |
        sed 's/^.\{'$len'\}.\(.*\)\.lib\.sh$/\1/'
  done
}

libs() # [Glob]
{
  libs_list "$@"
}

update() #
{
  test $# -eq 0 || return 99
  cd "$U_S"
  git fetch && git reset --hard origin/r0.0
}

reinstall() # [<ns_name>/<repo_name>]
{
  cd
  test $@ -gt 0 || set -- bvberkum/user-scripts
  test $# -eq 1 || return 99
  basher uninstall "$1" &&
  BASHER_FULL_CLONE=true basher install "$1"
  u-s update
}

redo_reinit() #
{
  test $# -eq 0 || return 99
  cd /src/github.com/apenwarr/redo &&
    sudo git clean -dfx &&
    sudo ./redo install
}

#
print_user_repo_description()
{
  { # Try to validate the .git is OK to catch some kinds of repo failures, but
    # not all. GIT fsck has no --quick or --quiet
    cd "$1" && git status
  } >/dev/null || return

  local descr="$( cd "$1" >/dev/null && git describe --always)"
  test -n "$descr" || return
  echo "$1 at GIT $descr"
}

# List raw func names as commands. TODO: indent spec maybe shortdescr nicely
commands() #
{
  test $# -eq 0 || return 99
  set -- "$0" $U_S/commands/*.lib.sh
  grep -h '^[a-z_][a-z0-9_]*()' "$@" | cut -d'{' -f1
}

# XXX: topic should be parts of files, not file names? Like commands. #MJfc
topics() #
{
  test $# -eq 0 || return 99
  local base="$U_S/src/man/"

  for sec in 1 2 3 4 5 6 7 8
  do
    test "$base$sec/*.md" != "$(echo $base$sec/*.md)" || continue
    for y in $base$sec/*.md
    do echo "$(basename $y .md) ($sec)"
    done
  done | sort
}

# TODO: print topic for section properly, sort content into sections. #MJfc
print_topic()
{
  test $# -eq 1 || return 99
  test -e $U_S/src/man/$1.md || return
  cat $U_S/src/man/$1.md
}

print_help()
{
  echo "Main commands: "
  echo "  libs - see libs-list"
  echo "  libs-grep <regex> - list matches for regex in sh-lib files"
  echo "  libs-list [glob] - list matching sh-lib names found on SCRIPTPATH"
  echo "  libs-paths [glob] - list full paths to lib files (with matching names)"
  echo
  echo "  update [version] - fetch and hard-reset to latest version"
  echo "  reinstall"
  echo
  echo "  dckr [CMD ARG...] - Execue U-S sub-command in container"
  echo "  dckr-init - Create docker container"
  echo "  dckr-reset - Delete docker container"
  echo "  dckr-shell CMD - Execute login shell at U-S dir"
  echo "  dckr-cmd CMD - Execute inline command with dckr-shell"
  echo "  dckr-cmd make [init|check|base|lint|units|specs|build|test|clean]"
  echo
  echo "  help [CMD-or-TOPIC] - Print this help, or manual section for topic."
  echo
  echo "Use 'commands' for a full list; or 'topics' to index other manuals."
}
print_usage()
{
  echo "Usage: u-s [CMD [ARG...]]"
}

help() # [Topic-ID]
{
  test $# -lt 2 || return 99
  test $# -gt 0 && {
    # TODO: print help for commands as well, maybe summaries for lists of topics @Docs
    print_topic "$@"
    return $?
  } || {
    print_usage
    print_help
  }
}

usage() #
{
  test $# -eq 0 || return 99
  help
  exit 1
}

version() #
{
  test $# -eq 0 || return 99
  echo "$U_S_VERSION"
}

main() # [SUBCMD [ARGS...]]
{
  # Get SCRIPTPATH and bootstrap libs
  init || return

  # Call sub-command shell function
  test $# -gt 0 || set -- usage
  test "$1" != "main" || return # NOTE: Huh. Sanity.

  mkvid "$1"
  local subcmd="$1" cmdid=$vid
  shift
  $vid "$@"
}

# TODO: make u-s proper install by expanding source below
. "$(dirname "$(realpath "$0")")/../tools/sh/u-s-env.sh"

# Setup to include other commands in parts to keep script size down.

test -d $U_S/commands -a -f "$U_S/tools/sh/init.sh" ||
  print_err "error" "" "Incomplete install, missing parts" \
    "$U_S/commands $U_S/tools/sh/init.sh"

for u_s_lib in $U_S/commands/u_s-*.lib.sh
do
  . "$u_s_lib"
done

main "$@"
