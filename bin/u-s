#!/usr/bin/env bash

# Initial CLI helper for any kind of U-S checkout or install

set -e # Sh, same as?:
set -o errexit # Ash, Bash
set -o nounset # Ash, Bash
set -o pipefail # Bash-only


init() #
{
  test -n "$U_S" || return 100

  sys_man=$(which man)
  man() { u_s_man; }
  : "${offline:=}"

  # Bootstrap SCRIPTPATH and default-libs, then return to main routine
  . $U_S/tools/sh/init.sh || {
    $PWD/tools/sh/log.sh "error" "" "During init.sh" $?
    return 1
  }
  INIT_LOG=$PWD/tools/sh/log.sh lib_init || {
    $PWD/tools/sh/log.sh "error" "" "During lib init" $?
    return 1
  }
  U_S_VERSION="$(u_s_version)"

  u_s_env_init
}

edit_docs() # [Files...]
{
  test $# -gt 0 || set -- $U_S/src/man/*/*.md
  $EDITOR "$@"
}

# Edit main command scripts or anything
edit() # [Files...]
{
  test $# -gt 0 || set -- "$@" $U_S/commands/u_s-*.lib.sh
  $EDITOR "$@"
}

# Grep all libs on SCRIPTPATH for expression
libs_grep() # Grep
{
  test $# -eq 1 || return
  local grep="$(libs_paths)"
  grep "$@" $grep
}

# List full path names for sh-lib files on SCRIPTPATH
libs_paths() # [Glob]
{
  test $# -eq 1 || set -- '*'
  echo "$SCRIPTPATH" | tr ':' '\n' | while read scriptpath
  do
    test -e "$scriptpath/$1.lib.sh" -o \
      "$scriptpath/*.lib.sh" != "$(echo $scriptpath/*.lib.sh|head -1)" ||
        continue
    echo $scriptpath/$1.lib.sh; done
}

# List only the names of sh-libs on SCRIPTPATH
libs_list() # [Glob]
{
  test $# -lt 2 || return
  test $# -eq 1 || set -- '*'
  echo "$SCRIPTPATH" | tr ':' '\n' | while read scriptpath
  do
    test -e "$scriptpath/$1.lib.sh" -o \
      "$scriptpath/*.lib.sh" != "$(echo $scriptpath/*.lib.sh|head -1)" ||
        continue

    # NOTE: no spaces on SCRIPTPATH
    len="${#scriptpath}"
    echo $scriptpath/$1.lib.sh | tr ' ' '\n' |
        sed 's/^.\{'$len'\}.\(.*\)\.lib\.sh$/\1/'
  done
}

# Listing matching lib names (see libs-list)
libs() # [Glob]
{
  libs_list "$@"
}

update() # [Repo-Release] [Repo-Id] [Repo-URL]
{
  test $# -le 3 || return 99
  test "$PWD" = "$U_S" || cd "$U_S"
  git_reset_hard "$@"
}

reinstall() # [<ns_name>/<repo_name>]
{
  cd  # Move out of U-s to HOME so CWD doesn't get confused
  u_s_reinstall
}

redo_reinit() #
{
  test $# -eq 0 || return 99
  cd /src/github.com/apenwarr/redo &&
    sudo git clean -dfx &&
    sudo ./redo install
}

# List raw func names as commands. TODO: indent spec maybe shortdescr nicely
commands() #
{
  test $# -eq 0 || return 99
  set -- "$0" $U_S/commands/*.lib.sh
  grep -h '^[a-z_][a-z0-9_]*()' "$@" | cut -d'{' -f1
}

print_help()
{
  echo "Main commands: "
  echo "  libs - see libs-list"
  echo "  libs-grep <regex> - list matches for regex in sh-lib files"
  echo "  libs-list [glob] - list matching sh-lib names found on SCRIPTPATH"
  echo "  libs-paths [glob] - list full paths to lib files (with matching names)"
  echo
  echo "  update [version] - fetch and hard-reset to latest version"
  echo "  reinstall"
  echo
  echo "  dckr [CMD ARG...] - Execue U-S sub-command in container"
  echo "  dckr-init - Create docker container"
  echo "  dckr-reset - Delete docker container"
  echo "  dckr-shell CMD - Execute login shell at U-S dir"
  echo "  dckr-cmd CMD - Execute inline command with dckr-shell"
  echo
  echo "  help [CMD-or-TOPIC] - Print this help, or manual section for topic."
  echo
  echo "Use 'commands' for a full list; or 'topics' to index other manuals."
}
print_usage()
{
  echo "Usage: u-s [CMD [ARG...]]"
}

help() # [Section] [Name]
{
  test $# -le 2 || return 99
  test $# -gt 0 && {
    # TODO: print help for commands as well, maybe summaries for lists of topics @Docs
    print_topic "$@"
    return $?
  } || {
    print_usage
    print_help
  }
}

usage() #
{
  test $# -eq 0 || return 99
  help
  exit 1
}

# Excho version retrieved from Git on load/init. See u-s-git and u-s-version.
version() #
{
  test $# -eq 0 || return 99
  echo "$U_S_VERSION"
}

main() # [SUBCMD [ARGS...]]
{
  print_err "info" "" "Initialzing shell..."
  # Get SCRIPTPATH and bootstrap libs
  init || return
  print_err "ok" "" "Initialized, booting cmd..."

  # Call sub-command shell function
  test $# -gt 0 || set -- usage
  test "$1" != "main" || return # NOTE: Sanity.

  mkvid "$1" || return
  local subcmd="$1" cmdid=$vid cmdgrp=

  test $# -eq 1 || {
    mkvid "$cmdid-$2" || return
    func_exists "$vid" && {
      print_err "info" "" "Found group-cmd" "$subcmd:$2"
      subcmd=$subcmd:$2 cmdgrp=$cmdid cmdid=$vid 
      shift
    }
  }
  shift
  $cmdid "$@"
}

# TODO: make u-s proper install by expanding source below
. "$(dirname "$(realpath "$0")")/../tools/sh/u-s-env.sh"

# Setup to include other commands in parts to keep script size down.

test -d $U_S/commands -a -f "$U_S/tools/sh/init.sh" ||
  print_err "error" "" "Incomplete install, missing parts" \
    "$U_S/commands $U_S/tools/sh/init.sh"

for u_s_lib in $U_S/commands/u_s-*.lib.sh
do
  . "$u_s_lib"
done

main "$@"
